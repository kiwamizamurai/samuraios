int main(void){

    int a = 1;
    int b = 2;
    int c = a + b;
    return c;
    }


// https://corgi-lab.com/programming/c-lang/reverse-assemble/

// reverse-engineering command is as follows:

// $ gcc test_01.c -g -c
// $ objdump test_01.o -S

// '-g' means DEBUG

//-------------------------------------
// push %rbp
// rbpはベースポインタと呼ばれるレジスタで、関数に割り当てられたスタック領域のベース（底）を示します。
// 関数が呼ばれた時点では、rbpには呼び出し元の関数のベースポインタの値が格納されているので、それを最初にpushすることで保存しているわけです。
//-------------------------------------
// mov %rsp,%rbp
// rspはスタックポインタと呼ばれるレジスタで、スタックの最上段（最も最後に参照された位置）を示します。
// この値をrbpに代入することで、いまのスタックポインタをこの関数におけるベースポインタとしています。
//-------------------------------------
// movl　$0x1,-0xc(%rbp)
// ここでは「int a = 1」に対応する命令として、movl命令により（rbp-0xc）のアドレスの内容に1を代入しています。
// ここでは変数aをint（=32bit）で宣言しているので、アセンブラ上もmovl命令が使われています。
//-------------------------------------
// movl　$0x2,-0x8(%rbp)
// 「int b = 2」に対応する命令です。さきほどと同様、movlにより（rbp-0x8）のアドレスの内容に2を代入しています。
// よく見ると、アドレスの位置が変数aから4バイト離れているので、変数aとbはメモリ上は連続した位置に置かれているようです。
//-------------------------------------
// mov -0xc(%rbp),%edx および mov -0x8(%rbp),%eax
// edxとeaxは汎用レジスタと呼ばれており、計算処理などに利用されます。
// ここでは、変数a,bの値をそれらのレジスタに一時的に格納しています。
//-------------------------------------
// add %edx,%eax
// ここでようやくa+bの計算が行われます。edxとeaxにはaとbの値が入っているので、eaxにa+bの結果が格納されます。
//-------------------------------------
// mov %eax,-0x4(%rbp)
// 上で計算したa+bの結果（eax）を変数cとして（rbp-0x4）のアドレスの内容に代入しています。
// これで、変数a,b,cのすべてに値が入った状態となりました。
//-------------------------------------
// mov -0x4(%rbp),%eax
// ここでは「return c」に対応する処理として、変数cの値を改めてeaxに代入しています。
// eaxは汎用レジスタの中でも戻り値の格納に使うことが決められているようです。
//-------------------------------------
// pop %rbp および retq
// 呼び出し元のベースポインタは最初にpushして覚えているので、その値をpopしてrbpへと書き戻しています。
// こうすることで、呼び出し元からすれば関数の前後でベースポインタが変わらないようにできます。最後はretqで関数の呼び出し元へと戻って終了です。
//-------------------------------------